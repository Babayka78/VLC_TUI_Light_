#!/bin/bash

# serials.sh - Библиотека для управления настройками сериалов
# Версия: 0.2.1
# Дата: 04.12.2025
# Changelog:
#   0.1.0 - Первая версия (файловое хранение)
#   0.2.0 - Переход на SQLite БД с композитным ключом
#   0.2.1 - Исправлен баг: Cancel/ESC теперь не сохраняют изменения в БД

# Подключаем БД библиотеку
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/db-manager.sh"

# Лог файл для отладки
LOG_DIR="$SCRIPT_DIR/Log"
LOG_FILE="$LOG_DIR/serials.log"
LOG_MAX_SIZE=1048576  # 1 MB максимальный размер

# Создать директорию для логов если нет
mkdir -p "$LOG_DIR"

# Функция ротации лога (если файл больше 1MB, оставляем последние 100KB)
rotate_log_if_needed() {
    if [ -f "$LOG_FILE" ]; then
        local log_size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null)
        if [ "$log_size" -gt "$LOG_MAX_SIZE" ]; then
            # Оставляем последние 100KB
            tail -c 102400 "$LOG_FILE" > "$LOG_FILE.tmp"
            mv "$LOG_FILE.tmp" "$LOG_FILE"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] === Лог ротирован (превысил 1MB) ===" >> "$LOG_FILE"
        fi
    fi
}

# Функция конвертации секунд в MM:SS
seconds_to_mmss() {
    local total_seconds="$1"
    
    # Если пустое значение - возвращаем пустую строку
    if [ -z "$total_seconds" ]; then
        echo ""
        return
    fi
    
    local minutes=$((total_seconds / 60))
    local seconds=$((total_seconds % 60))
    printf "%02d:%02d" "$minutes" "$seconds"
}

# Функция конвертации MM:SS в секунды
mmss_to_seconds() {
    local mmss="$1"
    
    # Если пустое значение - возвращаем пустую строку
    if [ -z "$mmss" ]; then
        echo ""
        return
    fi
    
    # Проверка формата MM:SS
    if [[ ! "$mmss" =~ ^[0-9]+:[0-9]{2}$ ]]; then
        echo "" # Некорректный формат
        return
    fi
    
    local minutes="${mmss%:*}"
    local seconds="${mmss#*:}"
    echo $((minutes * 60 + seconds))
}

# Функция для сохранения настроек в БД (вызывается только при OK)
save_settings_to_db() {
    local current_dir="$1"
    local filename="$2"
    local series_prefix="$3"
    local series_suffix="$4"
    local selected="$5"
    
    # Ротация лога
    rotate_log_if_needed
    
    # Логирование
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] === Сохранение настроек ===" >> "$LOG_FILE"
    echo "  Директория: $current_dir" >> "$LOG_FILE"
    echo "  Файл: $filename" >> "$LOG_FILE"
    echo "  Series prefix: $series_prefix" >> "$LOG_FILE"
    echo "  Series suffix: $series_suffix" >> "$LOG_FILE"
    echo "  Выбранные опции: $selected" >> "$LOG_FILE"
    
    # Конвертируем выбранные опции в 0/1
    local auto=0; echo "$selected" | grep -q "autoplay" && auto=1
    local intro=0; echo "$selected" | grep -q "skip_intro" && intro=1
    local outro=0; echo "$selected" | grep -q "skip_outro" && outro=1
    
    echo "  Значения: auto=$auto intro=$intro outro=$outro" >> "$LOG_FILE"
    
    # Сохраняем в БД
    db_save_series_settings "$series_prefix" "$series_suffix" $auto $intro $outro >> "$LOG_FILE" 2>&1
    
    local save_result=$?
    echo "  Результат сохранения: $save_result" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
}

# Функция для отображения меню настроек сериалов
# Параметры:
#   $1 - текущая директория (для поиска видеофайлов)
show_series_settings() {
    local current_dir="$1"
    
    # Найти первый видеофайл сериала в директории
    local first_video=$(find "$current_dir" -maxdepth 1 -type f \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" \) 2>/dev/null | head -1)
    
    if [ -z "$first_video" ]; then
        dialog --msgbox "Не найдено видеофайлов в директории" 7 50
        return 1
    fi
    
    local filename=$(basename "$first_video")
    local series_prefix=$(extract_series_prefix "$filename")
    local series_suffix=$(extract_series_suffix "$filename")
    
    # Если не сериал - выход
    if [ -z "$series_prefix" ]; then
        dialog --msgbox "Это не сериал" 7 40
        return 1
    fi
    
    # Загружаем настройки из БД
    local settings=$(db_get_series_settings "$series_prefix" "$series_suffix")
    
    # Парсим: autoplay|skip_intro|skip_outro|intro_start|intro_end|outro_start
    local autoplay="off"
    local skip_intro="off"
    local skip_outro="off"
    
    if [ -n "$settings" ]; then
        IFS='|' read -r auto intro outro intro_start intro_end outro_start <<< "$settings"
        [ "$auto" == "1" ] && autoplay="on"
        [ "$intro" == "1" ] && skip_intro="on"
        [ "$outro" == "1" ] && skip_outro="on"
    fi
    
    # Восстанавливаем TTY
    exec < /dev/tty
    exec > /dev/tty
    
    # Используем временный файл для корректной обработки exit code
    local tmpfile=$(mktemp)
    
    # Показываем checklist и сохраняем результат во временный файл
    dialog --output-fd 3 \
        --title "Настройки: $series_prefix" \
        --checklist "Выберите опции (SPACE для выбора):" 12 60 3 \
        "autoplay" "Автопродолжение следующей серии" $autoplay \
        "skip_intro" "Пропуск начальной заставки" $skip_intro \
        "skip_outro" "Пропуск конечных титров" $skip_outro \
        3>"$tmpfile" 2>/dev/tty
    
    local exit_code=$?
    local selected=$(cat "$tmpfile")
    rm -f "$tmpfile"
    
    # Если Cancel (exit_code=1) или ESC (exit_code=255) - выходим без сохранения
    if [ $exit_code -ne 0 ]; then
        return 0
    fi
    
    # Если OK (exit_code=0) - сохраняем
    save_settings_to_db "$current_dir" "$filename" "$series_prefix" "$series_suffix" "$selected"
}

# Функция для получения компактной строки статуса для подзаголовка
# Параметры:
#   $1 - директория
# Возвращает: строку вида "[X] Auto Continue  [ ] Intro  [X] Outro"
get_settings_status_compact() {
    local current_dir="$1"
    
    # Найти первый видеофайл
    local first_video=$(find "$current_dir" -maxdepth 1 -type f \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" \) 2>/dev/null | head -1)
    
    if [ -z "$first_video" ]; then
        echo ""  # Нет видео
        return
    fi
    
    local filename=$(basename "$first_video")
    local series_prefix=$(extract_series_prefix "$filename")
    local series_suffix=$(extract_series_suffix "$filename")
    
    if [ -z "$series_prefix" ]; then
        echo ""  # Не сериал
        return
    fi
    
    # Загружаем из БД
    local settings=$(db_get_series_settings "$series_prefix" "$series_suffix")
    
    local autoplay="0"
    local skip_intro="0"
    local skip_outro="0"
    local intro_start=""
    local intro_end=""
    local outro_start=""
    
    if [ -n "$settings" ]; then
        IFS='|' read -r autoplay skip_intro skip_outro intro_start intro_end outro_start <<< "$settings"
    fi
    
    # Формируем иконки
    local auto_icon=" "; [ "$autoplay" == "1" ] && auto_icon="X"
    local intro_icon=" "; [ "$skip_intro" == "1" ] && intro_icon="X"
    local outro_icon=" "; [ "$skip_outro" == "1" ] && outro_icon="X"
    
    # Формируем строку с временами
    local intro_times=""
    local outro_time=""
    
    # Intro: если есть хотя бы одно значение
    if [ -n "$intro_start" ] || [ -n "$intro_end" ]; then
        local start_mm=$(seconds_to_mmss "$intro_start")
        local end_mm=$(seconds_to_mmss "$intro_end")
        intro_times=": ${start_mm}-${end_mm}"
    fi
    
    # Outro: если есть значение
    if [ -n "$outro_start" ]; then
        local outro_mm=$(seconds_to_mmss "$outro_start")
        outro_time=": ${outro_mm}"
    fi
    
    echo "[$auto_icon] Auto  [$intro_icon] Intro${intro_times}  [$outro_icon] Outro${outro_time}"
}

# Функция для получения значения настройки (для использования в других скриптах)
# Параметры:
#   $1 - директория
#   $2 - ключ настройки (autoplay, skip_intro, skip_outro)
# Возвращает: "1" или "0" или пустую строку если не найдено
get_setting_value() {
    local current_dir="$1"
    local key="$2"
    
    # Найти первый видеофайл
    local first_video=$(find "$current_dir" -maxdepth 1 -type f \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" \) 2>/dev/null | head -1)
    
    if [ -z "$first_video" ]; then
        echo ""
        return
    fi
    
    local filename=$(basename "$first_video")
    local series_prefix=$(extract_series_prefix "$filename")
    local series_suffix=$(extract_series_suffix "$filename")
    
    if [ -z "$series_prefix" ]; then
        echo ""
        return
    fi
    
    # Загружаем из БД
    local settings=$(db_get_series_settings "$series_prefix" "$series_suffix")
    
    if [ -z "$settings" ]; then
        echo ""
        return
    fi
    
    # Парсим и возвращаем нужное значение
    IFS='|' read -r autoplay skip_intro skip_outro intro_start intro_end outro_start <<< "$settings"
    
    case "$key" in
        "autoplay")
            echo "$autoplay"
            ;;
        "skip_intro")
            echo "$skip_intro"
            ;;
        "skip_outro")
            echo "$skip_outro"
            ;;
        *)
            echo ""
            ;;
    esac
}
